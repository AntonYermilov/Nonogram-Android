package ru.spbau.nonograms.controller;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.widget.ImageView;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import ru.spbau.nonograms.client.ClientManager;
import ru.spbau.nonograms.local_database.CrosswordDBHelper;
import ru.spbau.nonograms.local_database.CrosswordInfo;
import ru.spbau.nonograms.local_database.CurrentCrosswordState;
import ru.spbau.nonograms.logic.NonogramImage;
import ru.spbau.nonograms.logic.NonogramLogic;
import ru.spbau.nonograms.model.Image;
import ru.spbau.nonograms.model.NonogramPreview;

/**
 * Controller connects all parts of the program.
 * Sometimes it does some "translation" between different parts.
 */
public class Controller {

    private static CrosswordDBHelper database;

    /**
     * Returns a picture of a crossword, generated by another picture.
     * @param givenImage an image to make crossword from.
     * @param width a width of crossword to make
     * @param height a height of crossword to make
     * @param colors number of colours in the crossword to make
     * @return a picture of a crossword, generated by another picture.
     */
    public static Bitmap makeCrosswordViewFromImage(ImageView givenImage, int width, int height, int colors) {
        return NonogramLogic.createNonogram(getBitmap(givenImage), width, height, colors);
    }

    /**
     * Returns last crossword made from picture.
     * @return last crossword made from picture.
     */
    public static CurrentCrosswordState getMadeCrosswordFromLastImage() {
        return NonogramLogic.getLastNonogram();
    }

    /**
     * Checks on server if crossword can be solved.
     * @param image a crossword to check
     * @return {@code true} if crossword can be solved, {@code false} otherwise.
     */
    boolean canBeSolvedOnServer(Image image) {
        return ClientManager.solveNonogram(image);
    }

    /**
     * Checks if crossword was solved right.
     * @param current a crossword to check
     * @return {@code true} if crossword is solved right, {@code false} otherwise.
     */
    public static boolean checkCorrectness(CurrentCrosswordState current) {
        for (int i = 0; i < current.getWidth(); i++) {
            for (int j = 0; j < current.getHeight(); j++) {
                if (current.getField(i, j).getValue() != CurrentCrosswordState.FILLED_CELL) {
                    current.setField(i, j, new CurrentCrosswordState.ColoredValue(
                            current.getField(i, j).getValue(), Color.WHITE));
                }
            }
        }
        return NonogramLogic.checkNonogram(current);
    }

    /**
     * A method to init a database.
     * @param context a context where the application is.
     */
    public static void initDatabase(Context context) {
        database = new CrosswordDBHelper(context);
    }

    /**
     * Returns list of information about crosswords in the local database.
     * @return list of information about crosswords in the local database.
     */
    public static ArrayList<CrosswordInfo> getLocalCrosswords() {
        return database.getAllCrosswords();
    }

    /**
     * Returns previews of crosswords stored on server.
     * @return previews of crosswords stored on server.
     */
    public static NonogramPreview[] getOnServerCrosswords() {
        return ClientManager.getNonogramPreviewInfo();
    }

    /**
     * Returns a crossword by its file name.
     * @param filename a name of a file, where crossword is stored.
     * @return a crossword by its file name.
     * @throws IOException if didn't manage to acces the file
     * @throws ClassNotFoundException if didn't manage to deserialize a crossword.
     */
    public static CurrentCrosswordState getLocalCrosswordByFilename(String filename)
            throws IOException, ClassNotFoundException {
        return database.getCrosswordByFilename(filename);
    }

    /**
     * Updates crossword in database by its filename
     * @param filename a name of a file, where crossword stores.
     * @param state a crossword to update with
     * @throws IOException if could't access the file
     */
    public static void updateLocalyByFilename(String filename, CurrentCrosswordState state) throws IOException {
        database.updateByFilename(filename, state);
    }

    /**
     * Adds crossword to local database by its field.
     * @param crossword a crossword to add
     * @param name a name of a crossword to store
     * @throws IOException if didn't manage to create/save to file
     */
    public static void addCrosswordLocallyByField(CurrentCrosswordState crossword, String name) throws IOException {
        NonogramImage ni = new NonogramImage(getClearFieldFromCrosswordState(crossword), Color.WHITE);
        database.addCrossword(transferNonogramImageToCrosswordState(ni), name, "anonymous");
    }

    /**
     * Adds crossword to local database by its rows' and columns' information.
     * @param crossword crossword to store
     * @param name a name of a crossword
     * @throws IOException if didn't manage to create file or save crossword there.
     */
    public static void addCrosswordLocallyByParametres(CurrentCrosswordState crossword, String name) throws IOException {
        database.addCrossword(crossword, name, "anonymous");
    }

    /**
     * Adds crossword to local database by its preview from server.
     * @param preview of a crossword from server.
     * @throws IOException if didn't manage to save crossword.
     */
    public static void addCrosswordLocallyByPreviewOnServer(NonogramPreview preview) throws IOException {
        CurrentCrosswordState crossword = ClientManager.getNonogramById(preview.id);
        database.addCrossword(crossword, preview.name, preview.author);
    }

    /**
     * Processes image on server to make in future nonogram from it.
     * @param image image to process
     * @return result of processing
     */
    public static Image createImageOnServer(Image image) {
        return ClientManager.createNonogram(image);
    }

    /**
     * Saves crossword on server by its field.
     * @param current a crossword to save
     * @param crosswordName name of a crossword
     */
    public static void addCrosswordOnServerByField(CurrentCrosswordState current, String crosswordName) {
        NonogramImage ni = new NonogramImage(getClearFieldFromCrosswordState(current), Color.WHITE);
        ClientManager.saveNonogram(transferNonogramImageToCrosswordState(ni), crosswordName, "anonymous");
    }

    /**
     * Adds crossword to server database by its rows' and columns' information.
     * @param state crossword to store
     * @param crosswordName a name of a crossword
     */
    public static void addCrosswordOnServerByParametres(CurrentCrosswordState state, String crosswordName) {
        ClientManager.saveNonogram(state, crosswordName, "anonymous");
    }

    private static CurrentCrosswordState transferNonogramImageToCrosswordState(NonogramImage ni) {
        int[] usedColors = Arrays.copyOfRange(ni.getUsedColors(), 1, ni.getUsedColors().length);
        int width = ni.getWidth();
        int height = ni.getHeight();
        CurrentCrosswordState.ColoredValue[][] columns = new CurrentCrosswordState.ColoredValue[width][];
        for (int i = 0; i < width; i++) {
            List<NonogramImage.Segment> col = ni.getColumn(i);
            columns[i] = new CurrentCrosswordState.ColoredValue[col.size()];
            for (int j = 0; j < columns[i].length; j++) {
                columns[i][j] = new CurrentCrosswordState.ColoredValue(col.get(j).getSize(),
                        ni.getRGBColor(col.get(j).getColorType()));
            }

        }
        CurrentCrosswordState.ColoredValue[][] rows = new CurrentCrosswordState.ColoredValue[height][];
        for (int i = 0; i < height; i++) {
            List<NonogramImage.Segment> row = ni.getRow(i);
            rows[i] = new CurrentCrosswordState.ColoredValue[row.size()];
            for (int j = 0; j < rows[i].length; j++) {
                rows[i][j] = new CurrentCrosswordState.ColoredValue(row.get(j).getSize(),
                        ni.getRGBColor(row.get(j).getColorType()));
            }

        }
        return new CurrentCrosswordState(rows, columns, usedColors, Color.WHITE, null);
    }

    private static int[][] getClearFieldFromCrosswordState(CurrentCrosswordState state) {
        int[][] result = new int[state.getHeight()][state.getWidth()];
        for (int i = 0; i < state.getHeight(); i++) {
            for (int j = 0; j < state.getWidth(); j++) {
                CurrentCrosswordState.ColoredValue val = state.getField(j, i);
                if (val.getValue() == CurrentCrosswordState.FILLED_CELL) {
                    result[i][j] = val.getColor();
                } else {
                    result[i][j] = Color.WHITE;
                }
            }
        }
        return result;
    }

    private static Bitmap getBitmap(ImageView givenImage) {
        BitmapDrawable bitmapDrawable = ((BitmapDrawable) givenImage.getDrawable());
        Bitmap bitmap;
        if (bitmapDrawable == null) {
            givenImage.buildDrawingCache();
            bitmap = givenImage.getDrawingCache();
            givenImage.buildDrawingCache(false);
        } else {
            bitmap = bitmapDrawable.getBitmap();
        }
        return bitmap;
    }
}
